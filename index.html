<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì—Ä–∞—Ñ–∏–∫ –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏</title>

    <!-- PWA –º–µ—Ç–∞—Ç–µ–≥–∏ -->
    <meta name="theme-color" content="#1a237e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å">

    <!-- –ò–∫–æ–Ω–∫–∞ (emoji —Å–æ–ª–Ω—Ü–µ) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚òÄÔ∏è</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚òÄÔ∏è</text></svg>">

    <link rel="manifest" href="manifest.json">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #1a237e;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
        }

        button:active {
            transform: scale(0.98);
        }

        #result {
            margin-top: 30px;
            display: none;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
            background: #f5f5f5;
            border-radius: 10px;
            overflow: hidden;
        }

        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: 600;
            color: #555;
        }

        .info-value {
            color: #333;
        }

        .alert {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .error {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 24px;
            }

            .chart-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚òÄÔ∏è –ì—Ä–∞—Ñ–∏–∫ –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏</h1>
        <p class="subtitle">–†–∞—Å—á–µ—Ç —Å—É–º–µ—Ä–µ–∫ –∏ –ø–æ–ª—è—Ä–Ω—ã—Ö –¥–Ω–µ–π/–Ω–æ—á–µ–π</p>

        <div class="input-group">
            <label>üìç –®–∏—Ä–æ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 59.93 –¥–ª—è –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–∞)</label>
            <input type="number" id="latitude" step="0.0001" placeholder="59.93" value="59.93">
        </div>

        <div class="input-group">
            <label>üìç –î–æ–ª–≥–æ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 30.34 –¥–ª—è –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–∞)</label>
            <input type="number" id="longitude" step="0.0001" placeholder="30.34" value="30.34">
        </div>

        <div class="row">
            <div class="input-group">
                <label>üìÖ –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞</label>
                <input type="date" id="startDate">
            </div>

            <div class="input-group">
                <label>üìÖ –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞</label>
                <input type="date" id="endDate">
            </div>
        </div>

        <button onclick="calculateLight()">üîç –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫</button>

        <div class="error" id="error"></div>

        <div id="result">
            <div class="chart-container">
                <canvas id="chart"></canvas>
            </div>

            <div class="info-card" id="polarInfo" style="display:none;">
                <h3 style="margin-bottom: 10px; color: #1a237e;">‚ö†Ô∏è –û—Å–æ–±—ã–µ –ø–µ—Ä–∏–æ–¥—ã</h3>
                <div id="polarDetails"></div>
            </div>
        </div>
    </div>

    <!-- SunCalc –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (–≤—Å—Ç—Ä–æ–µ–Ω–∞) -->
    <script>
    /*
     (c) 2011-2015, Vladimir Agafonkin
     SunCalc is a JavaScript library for calculating sun/moon position and light phases.
     https://github.com/mourner/suncalc
    */
    (function () { 'use strict';
    var PI = Math.PI, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan = Math.atan2, acos = Math.acos, rad = PI / 180;
    var dayMs = 1000 * 60 * 60 * 24, J1970 = 2440588, J2000 = 2451545;
    function toJulian(date) { return date.valueOf() / dayMs - 0.5 + J1970; }
    function fromJulian(j)  { return new Date((j + 0.5 - J1970) * dayMs); }
    function toDays(date)   { return toJulian(date) - J2000; }
    var e = rad * 23.4397;
    function rightAscension(l, b) { return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l)); }
    function declination(l, b)    { return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l)); }
    function azimuth(H, phi, dec)  { return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi)); }
    function altitude(H, phi, dec) { return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H)); }
    function siderealTime(d, lw) { return rad * (280.16 + 360.9856235 * d) - lw; }
    function astroRefraction(h) {
        if (h < 0) h = 0;
        return 0.0002967 / Math.tan(h + 0.00312536 / (h + 0.08901179));
    }
    function solarMeanAnomaly(d) { return rad * (357.5291 + 0.98560028 * d); }
    function eclipticLongitude(M) {
        var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M)),
            P = rad * 102.9372;
        return M + C + P + PI;
    }
    function sunCoords(d) {
        var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
        return { dec: declination(L, 0), ra: rightAscension(L, 0) };
    }
    var SunCalc = {};
    SunCalc.getPosition = function (date, lat, lng) {
        var lw  = rad * -lng, phi = rad * lat, d   = toDays(date),
            c  = sunCoords(d), H  = siderealTime(d, lw) - c.ra;
        return {
            azimuth: azimuth(H, phi, c.dec),
            altitude: altitude(H, phi, c.dec)
        };
    };
    var times = SunCalc.times = [
        [-0.833, 'sunrise',       'sunset'      ],
        [  -0.3, 'sunriseEnd',    'sunsetStart' ],
        [    -6, 'dawn',          'dusk'        ],
        [   -12, 'nauticalDawn',  'nauticalDusk'],
        [   -18, 'nightEnd',      'night'       ],
        [     6, 'goldenHourEnd', 'goldenHour'  ]
    ];
    SunCalc.addTime = function (angle, riseName, setName) {
        times.push([angle, riseName, setName]);
    };
    var J0 = 0.0009;
    function julianCycle(d, lw) { return Math.round(d - J0 - lw / (2 * PI)); }
    function approxTransit(Ht, lw, n) { return J0 + (Ht + lw) / (2 * PI) + n; }
    function solarTransitJ(ds, M, L)  { return J2000 + ds + 0.0053 * sin(M) - 0.0069 * sin(2 * L); }
    function hourAngle(h, phi, d) { return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d))); }
    function observerAngle(height) { return -2.076 * Math.sqrt(height) / 60; }
    function getSetJ(h, lw, phi, dec, n, M, L) {
        var w = hourAngle(h, phi, dec), a = approxTransit(w, lw, n);
        return solarTransitJ(a, M, L);
    }
    SunCalc.getTimes = function (date, lat, lng, height) {
        height = height || 0;
        var lw = rad * -lng, phi = rad * lat,
            dh = observerAngle(height),
            d = toDays(date), n = julianCycle(d, lw), ds = approxTransit(0, lw, n),
            M = solarMeanAnomaly(ds), L = eclipticLongitude(M), dec = declination(L, 0),
            Jnoon = solarTransitJ(ds, M, L),
            i, len, time, h0, Jset, Jrise;
        var result = {
            solarNoon: fromJulian(Jnoon),
            nadir: fromJulian(Jnoon - 0.5)
        };
        for (i = 0, len = times.length; i < len; i += 1) {
            time = times[i];
            h0 = (time[0] + dh) * rad;
            Jset = getSetJ(h0, lw, phi, dec, n, M, L);
            Jrise = Jnoon - (Jset - Jnoon);
            result[time[1]] = fromJulian(Jrise);
            result[time[2]] = fromJulian(Jset);
        }
        return result;
    };
    if (typeof exports === 'object' && typeof module !== 'undefined') module.exports = SunCalc;
    else if (typeof define === 'function' && define.amd) define(SunCalc);
    else window.SunCalc = SunCalc;
    }());
    </script>

    <script>
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–≥–æ–¥ –≤–ø–µ—Ä–µ–¥ –æ—Ç —Å–µ–≥–æ–¥–Ω—è)
        window.onload = function() {
            const today = new Date();
            const nextYear = new Date(today);
            nextYear.setFullYear(today.getFullYear() + 1);

            document.getElementById('startDate').value = today.toISOString().split('T')[0];
            document.getElementById('endDate').value = nextYear.toISOString().split('T')[0];

            // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js');
            }
        };

        function calculateLight() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);

            // –í–∞–ª–∏–¥–∞—Ü–∏—è
            const errorDiv = document.getElementById('error');
            if (isNaN(lat) || lat < -90 || lat > 90) {
                errorDiv.textContent = '‚ùå –®–∏—Ä–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç -90 –¥–æ 90';
                errorDiv.style.display = 'block';
                return;
            }
            if (isNaN(lon) || lon < -180 || lon > 180) {
                errorDiv.textContent = '‚ùå –î–æ–ª–≥–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç -180 –¥–æ 180';
                errorDiv.style.display = 'block';
                return;
            }
            if (startDate >= endDate) {
                errorDiv.textContent = '‚ùå –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –∫–æ–Ω–µ—á–Ω–æ–π';
                errorDiv.style.display = 'block';
                return;
            }

            errorDiv.style.display = 'none';

            // –í—ã—á–∏—Å–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
            const data = [];
            const polarInfo = [];
            let currentDate = new Date(startDate);

            while (currentDate <= endDate) {
                const times = SunCalc.getTimes(currentDate, lat, lon);
                const dateStr = currentDate.toISOString().split('T')[0];

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏
                let type = 'normal';
                if (!times.sunrise || !times.sunset || isNaN(times.sunrise.getTime()) || isNaN(times.sunset.getTime())) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Å–æ—Ç—É —Å–æ–ª–Ω—Ü–∞ –≤ –ø–æ–ª–¥–µ–Ω—å
                    const noonPos = SunCalc.getPosition(times.solarNoon, lat, lon);
                    if (noonPos.altitude > 0) {
                        type = 'polarDay';
                    } else {
                        type = 'polarNight';
                    }
                }

                data.push({
                    date: dateStr,
                    nightEnd: times.nightEnd,
                    nauticalDawn: times.nauticalDawn,
                    dawn: times.dawn,
                    sunrise: times.sunrise,
                    sunset: times.sunset,
                    dusk: times.dusk,
                    nauticalDusk: times.nauticalDusk,
                    night: times.night,
                    type: type
                });

                currentDate.setDate(currentDate.getDate() + 1);
            }

            // –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–∏–æ–¥—ã –ø–æ–ª—è—Ä–Ω—ã—Ö –¥–Ω–µ–π/–Ω–æ—á–µ–π
            let currentPolar = null;
            data.forEach((d, i) => {
                if (d.type !== 'normal') {
                    if (!currentPolar || currentPolar.type !== d.type) {
                        if (currentPolar) polarInfo.push(currentPolar);
                        currentPolar = { type: d.type, start: d.date, end: d.date };
                    } else {
                        currentPolar.end = d.date;
                    }
                } else {
                    if (currentPolar) {
                        polarInfo.push(currentPolar);
                        currentPolar = null;
                    }
                }
            });
            if (currentPolar) polarInfo.push(currentPolar);

            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            document.getElementById('result').style.display = 'block';
            drawChart(data);

            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—è—Ä–Ω—ã—Ö –ø–µ—Ä–∏–æ–¥–∞—Ö
            const polarInfoDiv = document.getElementById('polarInfo');
            const polarDetailsDiv = document.getElementById('polarDetails');
            if (polarInfo.length > 0) {
                polarInfoDiv.style.display = 'block';
                polarDetailsDiv.innerHTML = polarInfo.map(p => {
                    const icon = p.type === 'polarDay' ? 'üåû' : 'üåë';
                    const text = p.type === 'polarDay' ? '–ü–æ–ª—è—Ä–Ω—ã–π –¥–µ–Ω—å' : '–ü–æ–ª—è—Ä–Ω–∞—è –Ω–æ—á—å';
                    return `<div class="info-row">
                        <span class="info-label">${icon} ${text}</span>
                        <span class="info-value">${p.start} ‚Äî ${p.end}</span>
                    </div>`;
                }).join('');
            } else {
                polarInfoDiv.style.display = 'none';
            }
        }

        function drawChart(data) {
            const canvas = document.getElementById('chart');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä canvas
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;

            const w = canvas.width;
            const h = canvas.height;
            const padding = 60;
            const chartW = w - padding * 2;
            const chartH = h - padding * 2;

            // –û—á–∏—â–∞–µ–º canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);

            // –†–∏—Å—É–µ–º —Ñ–æ–Ω –≥—Ä–∞—Ñ–∏–∫–∞
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(padding, padding, chartW, chartH);

            // –í—Ä–µ–º–µ–Ω–Ω–∞—è —à–∫–∞–ª–∞ (0-24 —á–∞—Å–∞)
            const hours = 24;

            // –†–∏—Å—É–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (—á–∞—Å—ã)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= hours; i += 3) {
                const y = padding + (i / hours) * chartH;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartW, y);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(i + ':00', padding - 10, y + 4);
            }

            // –†–∏—Å—É–µ–º –¥–∞–Ω–Ω—ã–µ
            const step = chartW / data.length;

            data.forEach((d, i) => {
                const x = padding + i * step;

                if (d.type === 'polarDay') {
                    // –ü–æ–ª—è—Ä–Ω—ã–π –¥–µ–Ω—å - –≤–µ—Å—å –¥–µ–Ω—å —Å–≤–µ—Ç–ª–æ
                    ctx.fillStyle = 'rgba(255, 235, 59, 0.7)';
                    ctx.fillRect(x, padding, step, chartH);
                } else if (d.type === 'polarNight') {
                    // –ü–æ–ª—è—Ä–Ω–∞—è –Ω–æ—á—å - –≤–µ—Å—å –¥–µ–Ω—å —Ç–µ–º–Ω–æ
                    ctx.fillStyle = 'rgba(30, 30, 50, 0.8)';
                    ctx.fillRect(x, padding, step, chartH);
                } else {
                    // –û–±—ã—á–Ω—ã–π –¥–µ–Ω—å
                    const timeToY = (time) => {
                        if (!time || isNaN(time.getTime())) return null;
                        const hour = time.getHours() + time.getMinutes() / 60;
                        return padding + (hour / hours) * chartH;
                    };

                    const nightEndY = timeToY(d.nightEnd);
                    const nauticalDawnY = timeToY(d.nauticalDawn);
                    const dawnY = timeToY(d.dawn);
                    const sunriseY = timeToY(d.sunrise);
                    const sunsetY = timeToY(d.sunset);
                    const duskY = timeToY(d.dusk);
                    const nauticalDuskY = timeToY(d.nauticalDusk);
                    const nightY = timeToY(d.night);

                    // –ù–æ—á—å (–ø–æ–ª–Ω–∞—è —Ç–µ–º–Ω–æ—Ç–∞)
                    ctx.fillStyle = 'rgba(30, 30, 50, 0.9)';
                    if (nightEndY) ctx.fillRect(x, padding, step, nightEndY - padding);
                    if (nightY) ctx.fillRect(x, nightY, step, padding + chartH - nightY);

                    // –ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ —Å—É–º–µ—Ä–∫–∏
                    ctx.fillStyle = 'rgba(60, 60, 100, 0.7)';
                    if (nightEndY && nauticalDawnY) ctx.fillRect(x, nightEndY, step, nauticalDawnY - nightEndY);
                    if (nauticalDuskY && nightY) ctx.fillRect(x, nauticalDuskY, step, nightY - nauticalDuskY);

                    // –ù–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ —Å—É–º–µ—Ä–∫–∏
                    ctx.fillStyle = 'rgba(100, 100, 150, 0.6)';
                    if (nauticalDawnY && dawnY) ctx.fillRect(x, nauticalDawnY, step, dawnY - nauticalDawnY);
                    if (duskY && nauticalDuskY) ctx.fillRect(x, duskY, step, nauticalDuskY - duskY);

                    // –ì—Ä–∞–∂–¥–∞–Ω—Å–∫–∏–µ —Å—É–º–µ—Ä–∫–∏
                    ctx.fillStyle = 'rgba(150, 150, 200, 0.5)';
                    if (dawnY && sunriseY) ctx.fillRect(x, dawnY, step, sunriseY - dawnY);
                    if (sunsetY && duskY) ctx.fillRect(x, sunsetY, step, duskY - sunsetY);

                    // –î–µ–Ω—å (—Å–≤–µ—Ç–ª–æ)
                    ctx.fillStyle = 'rgba(255, 235, 59, 0.7)';
                    if (sunriseY && sunsetY) ctx.fillRect(x, sunriseY, step, sunsetY - sunriseY);
                }
            });

            // –ü–æ–¥–ø–∏—Å–∏ –¥–∞—Ç (–∫–∞–∂–¥—ã–µ N –¥–Ω–µ–π)
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            const labelStep = Math.max(1, Math.floor(data.length / 10));
            for (let i = 0; i < data.length; i += labelStep) {
                const x = padding + i * step;
                const dateStr = data[i].date.substring(5); // MM-DD
                ctx.save();
                ctx.translate(x, h - 10);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(dateStr, 0, 0);
                ctx.restore();
            }

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('–ì—Ä–∞—Ñ–∏–∫ –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏', w / 2, 20);

            // –õ–µ–≥–µ–Ω–¥–∞
            const legendX = w - 200;
            const legendY = padding + 10;
            const legends = [
                { color: 'rgba(255, 235, 59, 0.7)', text: '–î–µ–Ω—å' },
                { color: 'rgba(150, 150, 200, 0.5)', text: '–ì—Ä–∞–∂–¥. —Å—É–º–µ—Ä–∫–∏' },
                { color: 'rgba(100, 100, 150, 0.6)', text: '–ù–∞–≤–∏–≥. —Å—É–º–µ—Ä–∫–∏' },
                { color: 'rgba(60, 60, 100, 0.7)', text: '–ê—Å—Ç—Ä–æ–Ω. —Å—É–º–µ—Ä–∫–∏' },
                { color: 'rgba(30, 30, 50, 0.9)', text: '–ù–æ—á—å' }
            ];

            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            legends.forEach((leg, i) => {
                const y = legendY + i * 20;
                ctx.fillStyle = leg.color;
                ctx.fillRect(legendX, y, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText(leg.text, legendX + 20, y + 11);
            });
        }
    </script>
</body>
</html>